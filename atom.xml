<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>骑怪的梁阿无</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-01-31T09:38:55.657Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>梁阿无</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DeepSeek-V1本地化部署</title>
    <link href="http://example.com/articles/AI/DeepSeek-V1-%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%83%A8%E7%BD%B2"/>
    <id>http://example.com/articles/AI/DeepSeek-V1-%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%83%A8%E7%BD%B2</id>
    <published>2025-01-31T09:07:10.000Z</published>
    <updated>2025-01-31T09:38:55.657Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>除夕深度求索产品问世，Win本地化部署初尝。本文仅用作自己在学习路上遇到问题、解决问题方面的记录。如被提供给同样在此方面遇到问题的同学参考，不胜荣幸。若文中有出现纰漏不够严谨之处，望海涵。意见之处，不吝赐教。 <span id="more"></span></p><h3 id="产品安装"><a href="#产品安装" class="headerlink" title="产品安装"></a>产品安装</h3><p><a href="https://ollama.com/">官网</a></p><p><img src="D:%5CSoftware%5CBlog%5Csource%5C_posts%5CDeepSeek-V1-%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%83%A8%E7%BD%B2%5C03.png"></p><p>Download栏目 根据OS 确定产品支持类型</p><p><img src="D:%5CSoftware%5CBlog%5Csource%5C_posts%5CDeepSeek-V1-%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%83%A8%E7%BD%B2%5C01.png"></p><p>下载完成，执行exe文件，默认安装是在系统盘下。可通过调整环境变量调整文件存储路径。注：在未启动OLLAMA的情况下进行更改，如已经启动可重启OLLAMA。</p><p><img src="D:%5CSoftware%5CBlog%5Csource%5C_posts%5CDeepSeek-V1-%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%83%A8%E7%BD%B2%5C02.png"></p><h4 id="更改存储路径"><a href="#更改存储路径" class="headerlink" title="更改存储路径"></a>更改存储路径</h4><p>系统设置》关于》高级系统设置</p><p><img src="D:%5CSoftware%5CBlog%5Csource%5C_posts%5CDeepSeek-V1-%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%83%A8%E7%BD%B2%5C06.png"></p><p>系统级变量 key：OLLAMA_MODELS  value：需要存储的路径</p><p><img src="D:%5CSoftware%5CBlog%5Csource%5C_posts%5CDeepSeek-V1-%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%83%A8%E7%BD%B2%5C07.png"></p><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>可按需拉取 不同的语言模型，性能较差用1.5b，一般用7b，也可根据实际需要选择。推荐r1或者qwen2。</p><p>执行命令：ollama run deepseek-r1:7b</p><p>拉取成功后即可在命令行直接进行QA问答。</p><p><img src="D:%5CSoftware%5CBlog%5Csource%5C_posts%5CDeepSeek-V1-%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%83%A8%E7%BD%B2%5C08.png"></p><p><img src="D:%5CSoftware%5CBlog%5Csource%5C_posts%5CDeepSeek-V1-%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%83%A8%E7%BD%B2%5C09.png"></p><h3 id="UI界面"><a href="#UI界面" class="headerlink" title="UI界面"></a>UI界面</h3><p>如果需要可视化界面控制大模型，较为主流的两种工具如：chatBox、OI(Open webUI)。前者开箱即用，后者需要些许计算机基础。后者更贴合Ollama产品环境。</p><h4 id="ChatBox"><a href="#ChatBox" class="headerlink" title="ChatBox"></a>ChatBox</h4><p>网页版和本地下载均可</p><p><img src="D:%5CSoftware%5CBlog%5Csource%5C_posts%5CDeepSeek-V1-%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%83%A8%E7%BD%B2%5C10.png"></p><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p><img src="D:%5CSoftware%5CBlog%5Csource%5C_posts%5CDeepSeek-V1-%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%83%A8%E7%BD%B2%5C11.png"></p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p><img src="D:%5CSoftware%5CBlog%5Csource%5C_posts%5CDeepSeek-V1-%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%83%A8%E7%BD%B2%5C12.png"></p><h4 id="Open-WebUI"><a href="#Open-WebUI" class="headerlink" title="Open WebUI"></a>Open WebUI</h4><p><a href="https://docs.openwebui.com/">续，可参考官方文档</a></p><h3 id="Q-A"><a href="#Q-A" class="headerlink" title="Q/A"></a>Q/A</h3><p>Q1：本地Ollama无法被其他产品如ChatBox访问到</p><p>A1：环境变量 配置开放Host及跨域问题</p><p><img src="D:%5CSoftware%5CBlog%5Csource%5C_posts%5CDeepSeek-V1-%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%83%A8%E7%BD%B2%5C13.png"></p><p>续…</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;除夕深度求索产品问世，Win本地化部署初尝。本文仅用作自己在学习路上遇到问题、解决问题方面的记录。如被提供给同样在此方面遇到问题的同学参考，不胜荣幸。若文中有出现纰漏不够严谨之处，望海涵。意见之处，不吝赐教。</summary>
    
    
    
    <category term="AI" scheme="http://example.com/categories/AI/"/>
    
    
    <category term="DeepSeek" scheme="http://example.com/tags/DeepSeek/"/>
    
  </entry>
  
  <entry>
    <title>自定义注解实现</title>
    <link href="http://example.com/articles/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"/>
    <id>http://example.com/articles/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3</id>
    <published>2022-05-17T14:36:31.000Z</published>
    <updated>2022-05-19T16:01:14.180Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文仅用作自己在学习路上遇到问题、解决问题方面的记录。如被提供给同样在此方面遇到问题的同学参考，不胜荣幸。若文中有出现纰漏不够严谨之处，望海涵。意见之处，不吝赐教。</p><span id="more"></span><h3 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h3><ul><li><p>在对接Bpm宏天工作流时，需要传递指定格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;businessKey&quot;: &quot;string&quot;,</span><br><span class="line">  &quot;data&quot;: &quot;string&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其中businessKey是用来映射流程模型的，而data里存放的则是JSON格式的表单数据。对于表单数据仍然需要拥有“Key”来映射表单。</p></li><li><p>不同的流程需要映射不同的Key，不同的表单也需要映射不同的Key。因此在传递data数据进行对象的序列化时需要动态变更不同对象的序列化名称。常见的做法是封装成DTO进行集成Set，但是缺点在于存在不同类型对象多个流程情况下代码不够解耦。并且当属性名变更时更改代码显得效率不高。因而想要实现注解方式通过更改配置或公共常量来完成代码的解耦和业务场景的实现</p></li></ul><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><ol><li><p>泛型加注解</p></li><li><p>泛型的目的是为了容纳不同类别的对象</p></li><li><p>注解的目的是在对象序列化时动态调整对象的名称</p></li><li><p>经过相关学习了解到，SerializeFilter是通过编程扩展的方式定制fastjso序列化。fastjson支持6种SerializeFilter，用于不同场景的定制序列化。NameFilter是其中之一。</p></li><li><p>根据源码得知，NameFilter下有一个process接口，该接口的目的是序列化时返回指定的名称。结合本次业务场景重写process方法即可。</p><p><img src="https://raw.githubusercontent.com/liangawu/UploadImages/main/202205192358282.png"></p></li></ol><h3 id="定义注解前置学习"><a href="#定义注解前置学习" class="headerlink" title="定义注解前置学习"></a>定义注解前置学习</h3><ol><li>首先在定义注解前要了解，两个注解，@Rentention和@Target。</li><li>@Rentention主要是用来修饰注解的生命周期及作用范围，一共有RententionPolicy.SOURCE、RententionPolicy.CLASS、RententionPolicy.RUNTIME三种类型。默认是CLASS类型的，生命周期从小到大排序为SOURCE/CLASS/RUNTIME。</li><li>三者区别在于SOURCE只保留在源文件中，当.java编译成.class时注解就会消失。CLASS则会保留到变成.class的时候，但.class被加载成字节码的时候注解会消失，而RUNTIME存在的时间最久，在运行时仍然是生效的。</li><li>至于怎么选择三种类型以实际开发为准，像SOURCE这种存在时间短的一般二开应用场景不多，而CLASS这种一般用于编译时对代码规范的检查例如@Override等，而我选择RUNTIME是因为业务场景都是在系统运行时需要使用的。而@Target简而言之就是对注解使用范围的说明，包下、方法中、参数上等等。</li></ol><h3 id="实现思路及过程"><a href="#实现思路及过程" class="headerlink" title="实现思路及过程"></a>实现思路及过程</h3><ul><li><p>本次自定义注解实现时，定义了两个接口和一个实现类，最外层的注解是一个注解接口，MyParamName，MyParamName中存在两个属性，一个是默认序列化的名称，另一个是数组类型的动态取到的名称。</p><p><img src="https://raw.githubusercontent.com/liangawu/UploadImages/main/202205192359930.png"></p></li><li><p>其中数组类型是第二个注解，NameEle。NameEle中存在id和value两个参数。它的作用是在面对多个参数时，动态选择需要映射成的value，有点key-value的意思。当然这两个注解都属于可以运行时生效的注解。</p><p><img src="https://raw.githubusercontent.com/liangawu/UploadImages/main/202205192359294.png"></p></li><li><p>最后是定义实现类实现fastjson的nameFilter接口，重写process方法。</p><p><img src="https://raw.githubusercontent.com/liangawu/UploadImages/main/202205200000632.png"></p></li><li><p>重写的逻辑大致是通过反射获取注解名为MyParamName的注解，然后遍历MyParamName中的两个参数，如果默认序列化名称不为空且第二个注解参数NameEle为空则返回默认名称，此种情况用于判断单个参数的取值。如果NameEle非空，则通过遍历数组NameEle利用NameFilter定义的id属性和NameEle中的id进行匹配，取出指定的value值即可。</p></li></ul><h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><ul><li><p>泛型DTO</p><p><img src="https://raw.githubusercontent.com/liangawu/UploadImages/main/202205200000082.png"></p></li><li><p>动态序列化</p><p><img src="https://raw.githubusercontent.com/liangawu/UploadImages/main/202205200000084.png"></p></li><li><p>效果</p><p><img src="https://raw.githubusercontent.com/liangawu/UploadImages/main/202205200001754.png"></p></li></ul><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h3><ul><li>除了nameFilter外，fastjson还提供了PropertyPreFilter(根据Key判断是否序列化) 、PropertyFilter(根据属性名Key和属性值Value来判断是否序列化)、ValueFilter (修改Value)、BeforeFilter (序列化时在最前添加内容)、AfterFilter(序列化时在最后添加内容)等接口。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文仅用作自己在学习路上遇到问题、解决问题方面的记录。如被提供给同样在此方面遇到问题的同学参考，不胜荣幸。若文中有出现纰漏不够严谨之处，望海涵。意见之处，不吝赐教。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="序列化对象" scheme="http://example.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Docker记录(1)</title>
    <link href="http://example.com/articles/%E8%AE%A1%E7%AE%97%E6%9C%BA/article04-1"/>
    <id>http://example.com/articles/%E8%AE%A1%E7%AE%97%E6%9C%BA/article04-1</id>
    <published>2021-09-14T12:44:55.000Z</published>
    <updated>2021-09-14T12:54:54.727Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>本文仅用作自己在学习路上遇到问题、解决问题方面的记录。如被提供给同样在此方面遇到问题的同学参考，不胜荣幸。若文中有出现纰漏不够严谨之处，望海涵。意见之处，不吝赐教。<span id="more"></span></li></ul><h2 id="一、Docker的介绍及安装"><a href="#一、Docker的介绍及安装" class="headerlink" title="一、Docker的介绍及安装"></a>一、Docker的介绍及安装</h2><h3 id="1、什么是Docker"><a href="#1、什么是Docker" class="headerlink" title="1、什么是Docker"></a>1、什么是Docker</h3><p>Docker是基于Go语言实现的云开源项目</p><p>Docker的主要目标是一次封装、到处运行</p><p>Docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置，到处使用。</p><h3 id="2、Docker能干吗"><a href="#2、Docker能干吗" class="headerlink" title="2、Docker能干吗"></a>2、Docker能干吗</h3><p>以前的虚拟机：</p><ul><li>缺点：</li><li>资源占用多</li><li>冗余步骤多</li><li>启动慢</li></ul><p>Docker与传统虚拟机的区别：</p><ul><li>传统虚拟机技术是虚拟化一套硬件后，在其上运行一个完整的操作系统，在该系统上再运行所需应用进程</li><li>容器内的应用进程直接运行于宿主的内核。容器内没有自己的内核，而且也没有进行硬件虚拟，因此容器要比传统虚拟机更为轻便。</li><li>每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源</li></ul><h3 id="3、实际的运行"><a href="#3、实际的运行" class="headerlink" title="3、实际的运行"></a>3、实际的运行</h3><ul><li>更高效、更可预测</li><li>运维层面的产品，更简单的系统运维</li><li>应用更快速的部署</li></ul><h3 id="4、Docker的基本组成"><a href="#4、Docker的基本组成" class="headerlink" title="4、Docker的基本组成"></a>4、Docker的基本组成</h3><h4 id="4-1、镜像-image"><a href="#4-1、镜像-image" class="headerlink" title="4.1、镜像(image)"></a>4.1、镜像(image)</h4><p><strong>Docker镜像就是一个只读的模板</strong>，镜像可以用来创建Docker容器，一个镜像可以创建很多容器</p><h4 id="4-2、容器-container"><a href="#4-2、容器-container" class="headerlink" title="4.2、容器(container)"></a>4.2、容器(container)</h4><p>Docker利用容器独立运行的一个或者一组应用。容器是用镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做一个简易版的Linux环境(包括Root权限、进程空间、用户空间等)和运行在其中的应用程序。<strong>容器的定义和镜像几乎一摸一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是刻度、可写的。</strong></p><h4 id="4-3、仓库-repository"><a href="#4-3、仓库-repository" class="headerlink" title="4.3、仓库(repository)"></a>4.3、仓库(repository)</h4><p>仓库是集中存放镜像文件的场所。仓库分为公开和私有。仓库和仓库注册服务器是有所区别的。仓库注册服务器上存放多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签。</p><h2 id="二、Docker镜像介绍"><a href="#二、Docker镜像介绍" class="headerlink" title="二、Docker镜像介绍"></a>二、Docker镜像介绍</h2><h3 id="1、镜像是什么"><a href="#1、镜像是什么" class="headerlink" title="1、镜像是什么"></a>1、镜像是什么</h3><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包含代码、运行时、库、环境变量和配置文件。</p><h4 id="1-1、UnionFS"><a href="#1-1、UnionFS" class="headerlink" title="1.1、UnionFS"></a>1.1、UnionFS</h4><p>UnionFS(联合文件系统)：一种分层，轻量级并且高性能的文件系统。它支持对文件的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础，基于基础镜像(没有父镜像)，可以制作各种具体的应用镜像。</p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><h4 id="1-2、镜像加载原理"><a href="#1-2、镜像加载原理" class="headerlink" title="1.2、镜像加载原理"></a>1.2、镜像加载原理</h4><ul><li>Docker的镜像实际上是由一层一层的文件系统组成，这种层级的文件系统UnionFs。</li><li>Bootfs(boot file system)主要包含Bootloader和Kernel(操作系统内核)。Bootloader主要是引导加载Kernel，Linux刚启动时会加载Bootfs文件系统，在Docker的镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含Boot加载器和内核。当boot加载完成之后，整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</li><li>Rootfs(root file system)，在Bootfs之上，包含的就是典型Linux系统中的/dev/proc/bin/etc等标准目录和文件。Rootfs就是各种不同的操作系统发行版，比如Ubuntu,Centos等等。</li></ul><h4 id="1-3、分层的镜像"><a href="#1-3、分层的镜像" class="headerlink" title="1.3、分层的镜像"></a>1.3、分层的镜像</h4><p>pull的文件是一层一层拉取。</p><h4 id="1-4、分层结构的特点"><a href="#1-4、分层结构的特点" class="headerlink" title="1.4、分层结构的特点"></a>1.4、分层结构的特点</h4><ul><li>共享资源</li></ul><h3 id="2、镜像的特点"><a href="#2、镜像的特点" class="headerlink" title="2、镜像的特点"></a>2、镜像的特点</h3><p>Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部，这一层通常被称为容器层，容器层之下的都被叫镜像层。</p><h3 id="3、镜像的操作"><a href="#3、镜像的操作" class="headerlink" title="3、镜像的操作"></a>3、镜像的操作</h3><p>目的是将已改变的环境制作成一个新的镜像，在其他电脑使用的时候，可以直接拉取制作好的镜像即可完成环境的共享。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m =&quot;要提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure><h4 id="3-1、下载tomcat镜像"><a href="#3-1、下载tomcat镜像" class="headerlink" title="3.1、下载tomcat镜像"></a>3.1、下载tomcat镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat:8.5.64-jdk16-openjdk</span><br></pre></td></tr></table></figure><h4 id="3-2、创建容器并启动"><a href="#3-2、创建容器并启动" class="headerlink" title="3.2、创建容器并启动"></a>3.2、创建容器并启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 8888:8080 tomcat</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-p</td><td>主机端口：docker容器端口</td></tr><tr><td>-P</td><td>随机分配端口</td></tr><tr><td>-i</td><td>交互</td></tr><tr><td>-t</td><td>终端</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问</span><br><span class="line">http://虚拟机IP：8888</span><br></pre></td></tr></table></figure><p>命令补充</p><table><thead><tr><th>进入方式</th><th>说明</th></tr></thead><tbody><tr><td>exec</td><td>在容器中打开新的终端并且可以启动新的进程</td></tr><tr><td>attach</td><td>直接进入容器启动命令的终端，不会启动新的进程</td></tr></tbody></table><h4 id="3-3、修改容器"><a href="#3-3、修改容器" class="headerlink" title="3.3、修改容器"></a>3.3、修改容器</h4><p>发现启动的容器中没有要访问的资源，自己创建即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器ID /bin/bash</span><br><span class="line">mkdir root</span><br><span class="line">vi index.html</span><br><span class="line">echo hello &gt;&gt;index.html</span><br><span class="line">cat index.html</span><br><span class="line">在root文件夹中的index.html文件中存入hello内容</span><br></pre></td></tr></table></figure><h4 id="3-4、创建镜像"><a href="#3-4、创建镜像" class="headerlink" title="3.4、创建镜像"></a>3.4、创建镜像</h4><p>现在的容器和现在的有区别了，可以在此基础上创建新的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -a=&#x27;author&#x27; -m =&#x27;description message&#x27; 容器ID 名称/tomcat:版本</span><br></pre></td></tr></table></figure><h4 id="3-5、启动新的镜像"><a href="#3-5、启动新的镜像" class="headerlink" title="3.5、启动新的镜像"></a>3.5、启动新的镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 8888:8080 名称/tomcat:版本</span><br></pre></td></tr></table></figure><h2 id="三、Docker数据卷"><a href="#三、Docker数据卷" class="headerlink" title="三、Docker数据卷"></a>三、Docker数据卷</h2><h3 id="1、数据卷"><a href="#1、数据卷" class="headerlink" title="1、数据卷"></a>1、数据卷</h3><p>当容器停止获取删除后，容器中部分数据出现丢失现象，为了实现容器的数据持久化引入数据卷来解决这个问题。</p><h4 id="1-1、数据卷的定义"><a href="#1-1、数据卷的定义" class="headerlink" title="1.1、数据卷的定义"></a>1.1、数据卷的定义</h4><p>为了保存数据在docker中，我们使用卷的概念。容器卷就相当于Redis中持久化方式的RDB和AOF。</p><h4 id="1-2、解决的问题"><a href="#1-2、解决的问题" class="headerlink" title="1.2、解决的问题"></a>1.2、解决的问题</h4><p>完成数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p><p>特点：</p><ul><li>数据卷可以在容器之间共享或者重用数据</li><li>卷中的更改可以直接生效</li><li>数据卷中的更改不会包含在镜像的更新中</li><li>数据卷的生命周期一致持续到没有容器使用它为止</li></ul><p>持久化：容器间集成和共享数据</p><h4 id="1-3、数据卷的使用"><a href="#1-3、数据卷的使用" class="headerlink" title="1.3、数据卷的使用"></a>1.3、数据卷的使用</h4><h5 id="1-3-1、直接添加"><a href="#1-3-1、直接添加" class="headerlink" title="1.3.1、直接添加"></a>1.3.1、直接添加</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos:7</span><br><span class="line">//运行一个centos容器</span><br><span class="line">docker run -it centos:7</span><br><span class="line">//挂载数据到指定目录，执行完成会在宿主机和容器根目录下多出对应的文件</span><br><span class="line">docker run -it -v /宿主机路径:/容器内目录 镜像名</span><br><span class="line">eg：docker run -iy -v /mydatavolumecontainer/datavolumecontainer centos:7</span><br><span class="line">//通过inspect命令可以查看容器的详细信息</span><br><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure><p>数据共享的操作验证</p><ul><li><p>在宿主机里添加相应的文件内容，打开容器可以看到对应的内容</p></li><li><p>反之亦然</p></li><li><p>停掉容器重新启动发现数据依然存在</p></li></ul><p>权限控制：不允许在容器中进行修改</p><p>修改权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /宿主机绝对路径:/容器目录:ro 镜像名</span><br><span class="line">//ro --read only</span><br><span class="line">eg:docker run -iy -v /mydatavolumecontainer1/datavolumecontainer1 centos:7</span><br></pre></td></tr></table></figure><h5 id="1-3-2、DockerFiler添加"><a href="#1-3-2、DockerFiler添加" class="headerlink" title="1.3.2、DockerFiler添加"></a>1.3.2、DockerFiler添加</h5><p>宿主机根目录下创建一个mydocker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir mydocker</span><br><span class="line">//创建一个dockerfile1文件</span><br><span class="line">vim dockerfile1</span><br></pre></td></tr></table></figure><p>修改Volume信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> volume <span class="built_in">test</span></span></span><br><span class="line">FROM centos</span><br><span class="line">VOLUME [&quot;/dataVolumeContainer1&quot;,&quot;/dataVolumeContainer2&quot;]</span><br><span class="line">CMD echo &quot;finished,-----------success1&quot;</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p>根据这个DockerFile构建我们的镜像文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker build -f dockerFile1 -t 名称 .(加一个点)</span><br><span class="line">//-f是DockerFile文件的路径</span><br><span class="line">//是标签</span><br><span class="line">// .是当前的路径</span><br></pre></td></tr></table></figure><p>根据新创建的镜像文件创建容器，启动后可以看到容器中创建的对应的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it 名称</span><br></pre></td></tr></table></figure><p>这对应的目录和宿主机映射的路径的查找可以通过inspect命令查找</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure><p>验证和1.3.1验证方式相同</p><h3 id="2、数据卷容器"><a href="#2、数据卷容器" class="headerlink" title="2、数据卷容器"></a>2、数据卷容器</h3><p>命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据的容器，称之为数据卷容器。</p><h4 id="2-1、启动一个父容器"><a href="#2-1、启动一个父容器" class="headerlink" title="2.1、启动一个父容器"></a>2.1、启动一个父容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name dc01 名称/centos</span><br><span class="line">cd dataVolumeContainer1</span><br><span class="line">echo hello&gt;&gt;a.txt</span><br></pre></td></tr></table></figure><h4 id="2-2、创建两个子容器"><a href="#2-2、创建两个子容器" class="headerlink" title="2.2、创建两个子容器"></a>2.2、创建两个子容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name dc02 --volumes-from dc01 名称/centos</span><br><span class="line">docker run -it --name dc03 --volumes-from dc01 名称/centos</span><br></pre></td></tr></table></figure><ul><li>子容器共享父容器资源</li><li>修改任意子容器资源在另一个子容器中更新内容也是可见的</li></ul><p><strong>注意：删除dc01后，dc02和dc03之间的数据同样共享</strong></p><p>容器之间配置信息的传递，数据卷的生命周期一直持续到没有数据使用为止</p><h3 id="3、DockerFile"><a href="#3、DockerFile" class="headerlink" title="3、DockerFile"></a>3、DockerFile</h3><p>DockerFile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。</p><ul><li>编写DockerFile文件</li><li>docker build</li><li>docker run</li></ul><h4 id="3-1、构建过程"><a href="#3-1、构建过程" class="headerlink" title="3.1、构建过程"></a>3.1、构建过程</h4><ul><li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li><li>指令按照从上到下，顺序执行</li><li>#表示注释</li><li>每条指令都会创建一个新的镜像层，并对镜像提交</li></ul><h4 id="3-2、执行流程"><a href="#3-2、执行流程" class="headerlink" title="3.2、执行流程"></a>3.2、执行流程</h4><p>docker执行一个DockerFile脚本的流程大致如下：</p><ul><li>docker从基础镜像运行一个容器</li><li>执行一条指令并对容器做出修改</li><li>执行类似docker commit的操作提交一个新的镜像层</li><li>docker再基于刚提交的镜像运行一个新的容器</li><li>执行docker中的下一条指令直到所有指令都执行完成</li></ul><p>从软件的角度看，DockerFile、Docker镜像和Docker容器分别代表软件的三个不太阶段。</p><p>DockerFile：定义进程所需一切的文件</p><p>Docker镜像：编译后产生的镜像文件，当运行Docker镜像时，会真正开始提供服务</p><p>Docker容器：容器是直接提供服务的</p><h4 id="3-3、DockerFIle案例"><a href="#3-3、DockerFIle案例" class="headerlink" title="3.3、DockerFIle案例"></a>3.3、DockerFIle案例</h4><p>从官方pull下来的centos没有vim命令，将其强化</p><ul><li>编写DockerFile文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER bobo&lt;dengpbs.163.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo  &quot;success------666666&quot;</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><ul><li>构建镜像文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//docker build -f  DockerFile文件路径 -t 镜像名称:tag</span><br><span class="line">docker build -f dockerFile2 -t 名称/centos7:1.7 .</span><br></pre></td></tr></table></figure><ul><li>运行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it  名称/centos7:1.7</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;本文仅用作自己在学习路上遇到问题、解决问题方面的记录。如被提供给同样在此方面遇到问题的同学参考，不胜荣幸。若文中有出现纰漏不够严谨之处，望海涵。意见之处，不吝赐教。</summary>
    
    
    
    <category term="计算机" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Centos下部署docker及其他常用容器部署(1)</title>
    <link href="http://example.com/articles/%E8%AE%A1%E7%AE%97%E6%9C%BA/article04"/>
    <id>http://example.com/articles/%E8%AE%A1%E7%AE%97%E6%9C%BA/article04</id>
    <published>2021-07-20T13:53:02.000Z</published>
    <updated>2021-07-20T15:08:37.702Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>本文仅用作自己在学习路上遇到问题、解决问题方面的记录。如被提供给同样在此方面遇到问题的同学参考，不胜荣幸。若文中有出现纰漏不够严谨之处，望海涵。意见之处，不吝赐教。<span id="more"></span></li></ul><h2 id="一、Centos7下安装docker"><a href="#一、Centos7下安装docker" class="headerlink" title="一、Centos7下安装docker"></a>一、Centos7下安装docker</h2><p>1、Docker 要求 CentOS 系统的内核版本高于 3.10,通过 <strong>uname -r</strong> 命令查看你当前的内核版本.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><p>2、使用 <code>root</code> 权限登录 Centos。确保 yum 包更新到最新。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure><p>3、卸载旧版本(如果安装过旧版本的话)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker  docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure><p>4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>5、设置yum源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>6、可以查看所有仓库中所有docker版本，并选择特定版本安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure><p>7、安装docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce-17.12.0.ce</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>8、启动并加入开机启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure><p>9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h3 id="Tips：docker常用命令总结"><a href="#Tips：docker常用命令总结" class="headerlink" title="Tips：docker常用命令总结"></a>Tips：docker常用命令总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">重启docker</span><br><span class="line">systemctl restart docker</span><br><span class="line">关闭docker</span><br><span class="line">systemctl stop docker</span><br><span class="line">查看当前docker下运行的容器（正在运行的）</span><br><span class="line">docker ps</span><br><span class="line">查看所有的docker容器（包含已关闭的）</span><br><span class="line">docker ps -a</span><br><span class="line">启动容器</span><br><span class="line">docker start 容器名/容器ID/容器名字</span><br><span class="line">关闭容器</span><br><span class="line">docker stop 容器名/容器ID/容器名字</span><br><span class="line">删除容器的步骤，先删除容器再删除镜像，删除指定容器前要先停止指定容器的运行</span><br><span class="line">docker将容器重命名</span><br><span class="line">docker rename 旧名字 新名字</span><br><span class="line">启动docker容器</span><br><span class="line">docker run -d -i -t &lt;imageID&gt; /bin/bash </span><br><span class="line">检查docker是否被成功安装</span><br><span class="line">docker info</span><br><span class="line">docker的所有命令帮助</span><br><span class="line">docker help</span><br><span class="line">查看所有镜像列表</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><h2 id="二、Docker下安装jenkins"><a href="#二、Docker下安装jenkins" class="headerlink" title="二、Docker下安装jenkins"></a>二、Docker下安装jenkins</h2><p>1、启动docker，下载Jenkins镜像文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull jenkins/jenkins</span><br></pre></td></tr></table></figure><p>2、创建Jenkins挂载目录并赋予相应的权限，作用是便于修改配置文件（避免每次修改配置文件都要找到容器安装目录）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /var/jenkins_mount</span><br><span class="line">chmod 777 /var/jenkins_mount</span><br></pre></td></tr></table></figure><p>3、创建并启动Jenkins容器</p><p>　　<strong>-d 后台运行镜像</strong></p><p>　　-p 10240:8080 将镜像的8080端口映射到服务器的10240端口。</p><p>　　-p 10241:50000 将镜像的50000端口映射到服务器的10241端口</p><p>　 -v   /var/jenkins_mount:/var/jenkins_mount                /var/jenkins_home目录为容器jenkins工作目录，将硬盘上的一个目录挂载到这个位置，方便后续更新镜像后继续使用原来的工作目录。这里设置的就是上面创建的 /var/jenkins_mount目录</p><p>　　-v /etc/localtime:/etc/localtime让容器使用和服务器同样的时间设置。</p><p>　　–name myjenkins 给容器起一个别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 10240:8080 -p 10241:50000 -v /var/jenkins_mount:/var/jenkins_home -v /etc/localtime:/etc/localtime --name myjenkins jenkins/jenkins</span><br></pre></td></tr></table></figure><p>4、查看jenkins是否启动成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -l</span><br></pre></td></tr></table></figure><p>5、查看docker容器日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs myjenkins</span><br></pre></td></tr></table></figure><p>6、配置镜像加速，进入 cd /var/jenkins_mount/ 目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /var/jenkins_mount/</span><br></pre></td></tr></table></figure><p>修改 vi hudson.model.UpdateCenter.xml里的内容</p><p>将 url 修改为 清华大学官方镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</a></p><p>7、访问Jenkins页面，输入你的ip加上10240</p><p>8、管理员密码获取方法，编辑initialAdminPassword文件查看，把密码输入登录中的密码即可，开始使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /var/jenkins_mount/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure><h2 id="三、Docker下安装mysql"><a href="#三、Docker下安装mysql" class="headerlink" title="三、Docker下安装mysql"></a>三、Docker下安装mysql</h2><p>1、查询mysql镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><p>2、安装mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure><p>3、查看镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>4、在opt下创建文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/</span><br><span class="line">mkdir mysql_docker</span><br><span class="line">cd mysql_docker/</span><br><span class="line">echo $PWD</span><br></pre></td></tr></table></figure><p>5、启动mysql容器，在var/lib/docker/containers/下查看容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysqlserver -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d -i -p 3306:3306 mysql:latest</span><br><span class="line">-------------------------------</span><br><span class="line">cd /var/lib/docker/containers/</span><br></pre></td></tr></table></figure><p>6、查看mysql进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>7、进入mysql容器，并登陆mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysqlserver bash</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>8、开启远程访问权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">select host,user from user;</span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h3 id="Tips：日常docker启动MySQL总结"><a href="#Tips：日常docker启动MySQL总结" class="headerlink" title="Tips：日常docker启动MySQL总结"></a>Tips：日常docker启动MySQL总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/</span><br><span class="line">cd /mysql_docker/</span><br><span class="line">如果没有开启容器，先启动mysql容器</span><br><span class="line">docker start mysqlserver</span><br><span class="line">docker exec -it mysqlserver bash</span><br><span class="line">mysql -u root -p</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="四、Docker下安装redis"><a href="#四、Docker下安装redis" class="headerlink" title="四、Docker下安装redis"></a>四、Docker下安装redis</h2><p>1、安装gcc依赖，由于 redis 是用 C 语言开发，安装之前必先确认是否安装 gcc 环境（gcc -v），如果没有安装，执行以下命令进行安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc </span><br></pre></td></tr></table></figure><p>2、查询镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search redis</span><br></pre></td></tr></table></figure><p>3、拉取官方镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure><p>4、查看镜像是否成功安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>5、启动镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 -d redis:latest redis-server</span><br></pre></td></tr></table></figure><p>6、开启持久化配置 并挂载目录，作用同样是便于配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">菜鸟教程：</span><br><span class="line">docker run -p 6379:6379 -v $PWD/data:/data  -d redis:3.2 redis-server --appendonly yes</span><br><span class="line"></span><br><span class="line">命令说明：</span><br><span class="line">-p 6379:6379 : 将容器的6379端口映射到主机的6379端口</span><br><span class="line">-v $PWD/data:/data : 将主机中当前目录下的data挂载到容器的/data</span><br><span class="line">redis-server --appendonly yes : 在容器执行redis-server启动命令，并打开redis持久化配置</span><br></pre></td></tr></table></figure><p>7、查看容器启动情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>8、使用redis镜像执行redis-cli命令连接到刚启动的容器,主机IP为192.168.206.128</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it myredis(已改名，若未改名可直接使用容器ID或者容器名字) redis-cli</span><br></pre></td></tr></table></figure><p>9、连接远程（vm控制别的服务器）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis容器的名称 redis-cli -h 需要连接的服务器IP -p 6379 -a your_password </span><br><span class="line">//如果有密码 使用 -a参数</span><br></pre></td></tr></table></figure><p>10、被远程连接（vm被控制）</p><p>直接使用windows下的redis 的desktop manager输入远程服务器的IP和端口号即可</p><h3 id="Tips-连接redis的几种方式"><a href="#Tips-连接redis的几种方式" class="headerlink" title="Tips:连接redis的几种方式"></a>Tips:连接redis的几种方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker exec -ti d0b86(容器ID) redis-cli</span><br><span class="line"></span><br><span class="line">docker exec -ti d0b86 redis-cli -h localhost -p 6379 </span><br><span class="line">docker exec -ti d0b86 redis-cli -h 127.0.0.1 -p 6379 </span><br><span class="line">docker exec -ti d0b86 redis-cli -h 172.17.0.3 -p 6379 </span><br><span class="line"></span><br><span class="line">// 注意，这个是容器运行的ip，可通过 docker inspect redis_s | grep IPAddress 查看</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;本文仅用作自己在学习路上遇到问题、解决问题方面的记录。如被提供给同样在此方面遇到问题的同学参考，不胜荣幸。若文中有出现纰漏不够严谨之处，望海涵。意见之处，不吝赐教。</summary>
    
    
    
    <category term="计算机" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="Centos" scheme="http://example.com/tags/Centos/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/articles/uncategorized/hello-world"/>
    <id>http://example.com/articles/uncategorized/hello-world</id>
    <published>2021-07-01T07:55:29.388Z</published>
    <updated>2021-12-15T16:27:20.365Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>MyBatis持久性框架</title>
    <link href="http://example.com/articles/%E8%AE%A1%E7%AE%97%E6%9C%BA/article03"/>
    <id>http://example.com/articles/%E8%AE%A1%E7%AE%97%E6%9C%BA/article03</id>
    <published>2021-03-08T02:41:08.000Z</published>
    <updated>2021-03-08T08:16:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>1.本文仅用作自己在学习路上遇到问题、解决问题方面的记录。如被提供给同样在此方面遇到问题的同学参考，不胜荣幸。若文中有出现纰漏不够严谨之处，望海涵。意见之处，不吝赐教。<span id="more"></span></li><li>2.原始JDBC存在着频繁的连接、创建、释放导致系统资源浪费，从而影响性能，解决方法可以通过创建数据库连接池进行数据库性能的优化。</li><li>3.sql语句的变化较多，并且使用preparedstatement存在较多的硬编码，以及对结果集的解析也存在较多硬编码，耦合度比较高，因而想要用框架进行封装进而优化数据库，所以出现了Mybatis框架。</li><li>4.MyBatis是一款优秀的持久性框架，几乎免除了所有的JDBC代码以及设置参数和获取结果集的工作，MyBatis可以通过简单xml和注解来配置和映射原始类型、接口、和JavaPOJO**(Plain Old Java Objects,普通老式Java对象**)为数据库中的记录。</li><li>5.ORM框架（<strong>对象关系映射的缩写</strong>），MyBatis是一款基于ORM框架实现的半自动轻量级持久层框架。</li><li>6.开发流程：<ul><li>6.1.添加MyBatis的jar包</li><li>6.2.创建数据库实体表</li><li>6.3.编写User实体类（<strong>成员变量的类型要与数据库的数据的类型要一一对应</strong>）</li><li>6.4.编写映射实体类的xml文件<br>（通过配置类访问到对应实体类的映射文件xml，映射文件xml的定义：<br><code>&lt;mapper namespace=&quot;com.awu.mapper.UserMapper&quot;&gt;</code><br>根据namespace找到对应的实体类<figure class="highlight plaintext"><figcaption><span>id</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select * from user&lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;）```</span><br><span class="line">(*其中id 是对应的方法名，可以在执行时找到对应的实体类的代理对象的方法，resultType这是返回结果集的类型，此处表示是User类类型的*)</span><br><span class="line">   - 6.5.编写核心配置文件mybatis-config.xml</span><br><span class="line">   - 6.6.编写测试方法</span><br><span class="line">- 7.测试</span><br><span class="line">（*编写加载配置文件的路径，然后用*</span><br><span class="line">```Inputstream inutstream=Resource.getResourceAsStresm(resource )</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory =new SqlSessionFactoryBuilder().build(inputstream)//获得sqlsession工厂对象</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession sqlSession =sqlSessionFactory.openSession();//设置sqlsession对象</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; users=sqlSession.selectList(&quot;com.awu.UserMapper.findAll&quot;) //执行sql语句</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(User user : users)&#123;</span><br><span class="line">System.our.println(user.toString())&#125;//打印结果</span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure>）</li></ul></li><li>8.除了用这种sqlSession方式，还可以用MyBatis代理开发的方式，Mapper接口的开发方法需要程序员编写Mapper接口（<strong>相当于dao接口</strong>），由MyBatis框架根据接口定义创建接口的动态代理对象。</li><li>9.开发流程：<br>创建UserMapper接口，同时测试类中出现如下改动，在获取sqlSession对象后，不直接执行方法，而通过增加<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserMapper userMapper =sqlSession.getMapper(UserMapper.class);</span><br></pre></td></tr></table></figure>获取其代理对象，进而调用userMapper的方法。</li><li>10.Mapper.xml的namespace的全限定名和Mapper接口的全限定名一样。xml的id和Mapper接口的方法名要一致，并且Mapper接口方法的参数类型要和xml的resultType的类型要相同。</li><li>11.<strong>Mybatis常用的API</strong><ul><li>sqlSession</li><li>sqlSessionFactory <em>工厂对象</em> </li><li>Resource <em>资源类</em></li><li>sqlSession.opneSession()</li></ul><em>//无参数表示非自动提交，有参数TRUE表示事务是自动提交的。</em><ul><li>sqlSession <em>会话对象</em><br>（<em>包含执行语句，提交或者回滚以及获取映射器实例的方法</em>）</li></ul></li><li>12.（16:05）<strong>environment标签和mapper标签</strong><br>（<em>配置文件找到映射文件，映射文件再根据命名空间和id找到具体的类的具体的方法</em>）</li><li>13.MyBatis的增删改查-<em>映射文件内标签内容的书写</em><ul><li>13.1.－－<strong>根据用户编号查找用户信息</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id=#&#123;id&#125;(使用这条语句的同时还需要在标签头添加参数标签，用以封装传过来的参数，其中#&#123;id｝就是传进来封装的参数值</span><br></pre></td></tr></table></figure></li><li>13.2.－－<strong>根据用户名模糊查询用户信息</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where username like &#x27;%$&#123;value&#125;%&#x27;</span><br></pre></td></tr></table></figure></li><li>13.3.－－<strong>添加客户信息</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert&gt;</span><br><span class="line">insert into user&#123;username,jobs,phone&#125;values &#123;#&#123;username&#125;,#&#123;jobs,#&#123;phone&#125;&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><em>｛内容｝表示由用户传进来的参数的封装</em></p><ul><li>13.4.－－<strong>更新用户信息</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;update&gt;</span><br><span class="line">update user set username=#&#123;username&#125;,jobs=#&#123;jobs&#125;,phone=#&#123;phone&#125; where id=#&#123;id&#125;</span><br></pre></td></tr></table></figure></li><li>13.5.－－<strong>删除用户信息</strong>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;delete&gt;</span><br><span class="line">delete from user where id=#&#123;id&#125;</span><br></pre></td></tr></table></figure></li><li>14.*<em>MyBatis原理：**</em>  </li></ul><p><em>实现方式两种：sqlsession和基于sqlsession的mapper代理对象</em><br>功能架构分为三层：<br>接口层、数据处理层、框架支撑层<br>（增加数据接口&lt;－－参数映射，SQL解析，SQL执行，结果处理和映射&lt;－－xml配置，基于注解的配置）</p><ul><li>15.<strong>MyBatis的一级缓存和二级缓存：</strong><br>一级缓存是默认开启的，二级缓存是需要手动进行配置的，开启后的二级缓存还需要将实体类pojo实现serializable接口。数据的查询首先是查缓存，如果缓存中没有则再向数据库中找。所以在一二级缓存都存在的情况下，查询的流程是，首先在二级缓存中找同一个namespace下的多个sqlSession对象，然后通过一级缓存在每个sqlSession内查找数据，可以说二级缓存是基于命名空间查找的（<em>基于mapper映射文件的namspace实现的</em>），一级缓存是基于sqlSession查找的（<em>基于sqlSession实现的</em>），如果都找不到再查询数据库。</li><li>16.二级缓存什么时候失效什么时候生效？<br> 答：当执行的sqlSession对象是位于同一个命名空间的不同sqlSession对象时，sql语句执行commit或close，一级缓存失效二级缓存生效，sql语句执行增删改操作时二级缓存失效一级缓存生效。</li></ul><hr><p>   <img src="%5Carticle03%5C03-01.jpg"> </p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;1.本文仅用作自己在学习路上遇到问题、解决问题方面的记录。如被提供给同样在此方面遇到问题的同学参考，不胜荣幸。若文中有出现纰漏不够严谨之处，望海涵。意见之处，不吝赐教。</summary>
    
    
    
    <category term="计算机" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="MyBatis" scheme="http://example.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Dao层和Service层的记录(1)</title>
    <link href="http://example.com/articles/%E8%AE%A1%E7%AE%97%E6%9C%BA/article02"/>
    <id>http://example.com/articles/%E8%AE%A1%E7%AE%97%E6%9C%BA/article02</id>
    <published>2021-03-08T02:05:24.000Z</published>
    <updated>2021-03-08T02:26:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>1.本文仅用作自己在学习路上遇到问题、解决问题方面的记录。如被提供给同样在此方面遇到问题的同学参考，不胜荣幸。若文中有出现纰漏不够严谨之处，望海涵。意见之处，不吝赐教。<span id="more"></span></li><li>2.mvc是一种结构模式，通过结构的设计达到程序解耦的作用。</li><li>3.mvc调用过程：表示层调用控制层，控制层调用服务层，服务层调用Dao层。</li><li>4.其实控制层做的事就是处理请求的路径，用RequestMapping(“/“)对类或者方法使用。放在类前表示这个资源请求的父路径，然后在具体的方法前使用@GetMapping(“/“)表示调用对应方法时具体的路径。<ul><li>4.1.例如在Test类前添加@RequestMapping(“/user”)，其中Test类有一个名叫findAll的方法，那么可以在此方法前加GetMapping(“/findAll”)，当调用findAll方法的时候。在web请求中的路径即为localhost：8080/user/findAll。</li></ul></li><li>5.至于@GetMapping(“/“)等价于@RequestMapping(“method= Request Method.GET”)，同理，PostMapping(“/“)，DeleteMapping(“/“)亦是如此。</li><li>6.至于Service层的作用，就是调Dao层的接口，用接口的原因，因java类是单继承，接口是多继承，在同一个Service接口中可以调用许多不同的Dao接口的方法。Dao层主要是实现了对数据库的访问，实现对数据库的增删改查。Service层为是为了丰富业务逻辑。<ul><li>6.1.譬如对用户登录的业务流程，Dao层是为了查询数据库是否有这样的对象并返回。Service层则是通过调用Dao的许多方法来完善这个登录的业务逻辑，调用的方法包括对数据库对应内容的查询。</li></ul></li><li>7.不使用Service层的话，那么如果想要换一种数据库语言的话，则需要对所有访问数据库的方法进行修改。如果使用了服务层，那么，只需要Dao层接口进行修改就可以了。服务层不需要做任何的改动。既实现了代码的重用，又实现了解耦。</li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;1.本文仅用作自己在学习路上遇到问题、解决问题方面的记录。如被提供给同样在此方面遇到问题的同学参考，不胜荣幸。若文中有出现纰漏不够严谨之处，望海涵。意见之处，不吝赐教。</summary>
    
    
    
    <category term="计算机" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="Java-Spring MVC" scheme="http://example.com/tags/Java-Spring-MVC/"/>
    
  </entry>
  
  <entry>
    <title>重装Window10系统</title>
    <link href="http://example.com/articles/%E8%AE%A1%E7%AE%97%E6%9C%BA/article01"/>
    <id>http://example.com/articles/%E8%AE%A1%E7%AE%97%E6%9C%BA/article01</id>
    <published>2021-01-29T08:24:03.000Z</published>
    <updated>2021-01-29T14:13:52.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>1.本文仅用作自己在学习路上遇到问题、解决问题方面的记录。如被提供给同样在此方面遇到问题的同学参考，不胜荣幸。若文中有出现纰漏不够严谨之处，望海涵。意见之处，不吝赐教。<span id="more"></span></li><li>2.安装方式有直接在本地安装和U盘安装两种，我采用的是U盘作为启动盘安装镜像文件重做的Windows系统。</li><li>3.(以Win10为例) 安装所需：一个8G以上的空白U盘(有重要的文件可以先copy下来)，Windows10的镜像文件(没有可以在网上下载),一台正常运行的电脑。</li><li>4.插曲： 我在制作U盘启动盘的时候，手边就找到一个U盘，还是商家赠的，被写入了某种保护，不能正常存储。当然如果要重装系统必须要一个空白的可读可写的，所以经过相关了解采用如下的方式完成了普通U盘的还原。<ul><li>4.1. 下载ChipGenius芯片精灵软件，解压后执行.exe，而后插入U盘，检测U盘的供应商、设备名称、协议版本，最重要的是记下主控厂商和主控型号</li><li>4.2. 搜索”U盘量产网”，根据U盘的主控厂商和主控型号寻找对应的量产工具并下载。(以慧荣为例)<br><img src="http://lc-7vdt0zmw.cn-n1.lcfile.com/79e1fbadc544676be3cc.png/U%E7%9B%98%E9%87%8F%E4%BA%A7%E5%B7%A5%E5%85%B7.png" alt="U盘量产工具"></li><li>4.3. 下载完成后，软件所示如图，插入损坏的U盘后，某一Port的进程的进度条会变蓝，然后Start等待完成即可，参数默认，完成后拔插一次U盘即可完成U盘的还原。<br><img src="http://lc-7vdt0zmw.cn-n1.lcfile.com/134559edcb5cf292151c.png/%E9%87%8F%E4%BA%A7%E8%BD%AF%E4%BB%B6%E7%A4%BA%E4%BE%8B.png" alt="量产软件示例"></li></ul></li><li>5.最后再将U盘格式化一遍并把下载的Win10镜像文件放在U盘根目录下。至此，U盘的修复工作完成，即可投入正常使用。步入正题，制作U盘为启动盘。我用的是大白菜U盘制作软件。下载”大白菜超级U盘制作工具”，安装完成后执行即可识别插入的U盘，参数默认即可。点击一键USB启动盘，耐心等待完成。<br>  <img src="http://lc-7vdt0zmw.cn-n1.lcfile.com/82ad39763d74e8d438db.png/%E5%A4%A7%E7%99%BD%E8%8F%9C%E8%BD%AF%E4%BB%B6%E7%95%8C%E9%9D%A2%E7%A4%BA%E4%BE%8B.png" alt="大白菜软件界面示例"></li><li>6.完成后拔掉U盘重启电脑，第一次首先要进入BIOS(Basic Input Output System)。各大品牌电脑进入BIOS的按键不一，以Haier为例，详细机型查询下图。按F12或Del进入BIOS的设置界面。之所以要进入BIOS，说到底使用U盘的镜像安装系统，则需要先把U盘里的系统安装到电脑硬盘中替换电脑原来的系统(可以制作不同的启动盘完成Win7、Win10等多个版本的系统，在电脑启动之初可以选择启动的系统版本)，然后U盘拔出，电脑选择启动更新过的系统即可。首先需要将电脑默认的优先启动项设置成U盘否则默认进入的是电脑硬盘里存在的系统。<br>  <img src="http://lc-7vdt0zmw.cn-n1.lcfile.com/15fede6940ee012b0e06.png/%E5%90%84%E7%94%B5%E8%84%91BIOS%E7%83%AD%E9%94%AE%E6%A0%B7%E5%9B%BE.png" alt="各电脑BIOS热键样图"></li><li>7.进入BIOS的界面后，按方向键移动到”Boot”选项<br>  <img src="http://lc-7vdt0zmw.cn-n1.lcfile.com/bde762d762610c227b05.png/Haier%E7%A4%BA%E4%BE%8B.png" alt="Haier示例"></li><li>8.下方”Set Boot Priority”即设置系统的优先级，选择”1st Boot”按”Enter”在下拉选项里选择”USB Disk”的字样再次按回车，同样的设置硬盘启动为”2nd Boot ”。按”F10”保存退出。然后把U盘插入重启电脑，此时电脑进入的就是U盘的PE界面，所谓PE界面就是Windows的预安装环境。</li><li>9.进入PE界面后，选择”启动Win10 X64PE(2G以上内存)”，然后加载进入到了预安装的桌面，里面有”大白菜装机”点击执行，弹出界面选择下载好的镜像文件并选中盘符C作为系统盘，然后点击安装系统即可<br>  <img src="http://lc-7vdt0zmw.cn-n1.lcfile.com/8ddaaa4bff8cb682b61f.png/%E5%A4%A7%E7%99%BD%E8%8F%9CPE%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2.png" alt="大白菜PE管理界面"></li><li>10.PE的桌面还有一个分区工具，点击进入删除原有的所有分区(包括C分区)，删除后左上角点击磁盘，转换磁盘为GUID或者MBR模式，我选的是MBR，如果转换为GUID则会出现两个隐藏分区。转换为MBR模式后，保存更改，再选择快速分区，给系统盘分的多一些，我划分了80G，然后勾选”4个分区”、”对齐参数”字样，这样其余的空间就平均分给了除系统盘之外的盘符。最后保存更改。<br>  <img src="http://lc-7vdt0zmw.cn-n1.lcfile.com/56b0a38cb8802d42e757.png/%E5%88%86%E5%8C%BA%E5%B7%A5%E5%85%B7.png" alt="分区工具"><ul><li>10.1.小插曲： 之前选择的是GUID格式，但是导致了在优先级设置正常的情况下，重新启动电脑出现了”Invalid Partition table”分区表错误的字样进入不了系统。于是将GUID格式转换为MBR格式并重建主引导记录后无异常</li><li>10.2.<strong>关于GUID和MBR区别的相关资料：</strong><ul><li>10.2.1.分区表安全性不同。MBR的意思是“主引导记录”，它有自己的启动器，也就是启动代码，一旦启动代码被破坏，系统就没法启动，只有通过修复才能启动系统。而GUID分区表自带备份，在磁盘的首尾部分分别保存了一份相同的分区表。其中一份被破坏后，可以通过另一份恢复。</li><li>10.2.2.支持磁盘容量大小不同。MBR分区方案无法支持超过2TB容量的磁盘,也即3TB硬盘以MBR分区方案分区,有三分之一容量会认不到。以GUID分区表(GPT)方案分区则可认到最大18EB(18X1024GB)容量的磁盘。</li><li>10.2.3.分区个数不同。使用MBR分区表的硬盘最多只能划分4个主分区磁盘，而GPT分区表类型，此分区表类型不受分区个数限制。限制只在于操作系统——Windows支持最多128个GPT分区，而且你还不需要创建扩展分区</li><li>10.2.4.分区标识不同：GUID分区，每个分区可以有一个名称(不同于卷标)。</li></ul></li></ul></li><li>11.解决完所有问题后，再次进入BIOS设置硬盘为第一启动项，重启即可。由于之前把硬盘设置为了第二启动项，所以在完成之后只需要拔掉U盘即可进入硬盘安装好的系统了。</li><li>12.进入安装好的系统发现的问题：<ul><li>12.1.驱动问题：可以下载好驱动精灵等驱动软件到一个完好的U盘中(非启动盘)，然后copy到新系统的桌面安装更新驱动即可</li><li>12.2.桌面图标过大，分辨率不行：右键显示设置调节分辨率、缩放和桌面图标大小即可。我选的是1600x900。此外分辨率的好坏与显卡和显示器都有关系</li></ul></li></ul><hr><pre><code>至此，重装Win10的过程就到此结束了。对于过程中遇到的问题和困难，也算是大同小异，仅作记录用以提醒。不积跬步无以至千里，不积小流无以成江海。祝各位，前程似锦，不忘初心。</code></pre>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;1.本文仅用作自己在学习路上遇到问题、解决问题方面的记录。如被提供给同样在此方面遇到问题的同学参考，不胜荣幸。若文中有出现纰漏不够严谨之处，望海涵。意见之处，不吝赐教。</summary>
    
    
    
    <category term="计算机" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
  </entry>
  
</feed>
